{"version":3,"sources":["default~library-library-module~live-live-module~organisation-organisation-module-es5.js","webpack:///node_modules/ngx-infinite-scroll/modules/ngx-infinite-scroll.js"],"names":[],"mappings":"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","file":"x","sourcesContent":["(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[\"default~library-library-module~live-live-module~organisation-organisation-module\"],{\n\n/***/ \"./node_modules/ngx-infinite-scroll/modules/ngx-infinite-scroll.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/ngx-infinite-scroll/modules/ngx-infinite-scroll.js ***!\n  \\*************************************************************************/\n/*! exports provided: InfiniteScrollDirective, InfiniteScrollModule */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InfiniteScrollDirective\", function() { return InfiniteScrollDirective; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InfiniteScrollModule\", function() { return InfiniteScrollModule; });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm2015/core.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm2015/index.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm2015/operators/index.js\");\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @param {?} fromRoot\n * @return {?}\n */\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n    /** @type {?} */\n    const hasWindow = window && !!window.document && window.document.documentElement;\n    /** @type {?} */\n    let container = hasWindow && scrollWindow ? window : defaultElement;\n    if (selector) {\n        /** @type {?} */\n        const containerIsString = selector && hasWindow && typeof selector === 'string';\n        container = containerIsString\n            ? findElement(selector, defaultElement.nativeElement, fromRoot)\n            : selector;\n        if (!container) {\n            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n        }\n    }\n    return container;\n}\n/**\n * @param {?} selector\n * @param {?} customRoot\n * @param {?} fromRoot\n * @return {?}\n */\nfunction findElement(selector, customRoot, fromRoot) {\n    /** @type {?} */\n    const rootEl = fromRoot ? window.document : customRoot;\n    return rootEl.querySelector(selector);\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction inputPropChanged(prop) {\n    return prop && !prop.firstChange;\n}\n/**\n * @return {?}\n */\nfunction hasWindowDefined() {\n    return typeof window !== 'undefined';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst VerticalProps = {\n    clientHeight: \"clientHeight\",\n    offsetHeight: \"offsetHeight\",\n    scrollHeight: \"scrollHeight\",\n    pageYOffset: \"pageYOffset\",\n    offsetTop: \"offsetTop\",\n    scrollTop: \"scrollTop\",\n    top: \"top\"\n};\n/** @type {?} */\nconst HorizontalProps = {\n    clientHeight: \"clientWidth\",\n    offsetHeight: \"offsetWidth\",\n    scrollHeight: \"scrollWidth\",\n    pageYOffset: \"pageXOffset\",\n    offsetTop: \"offsetLeft\",\n    scrollTop: \"scrollLeft\",\n    top: \"left\"\n};\nclass AxisResolver {\n    /**\n     * @param {?=} vertical\n     */\n    constructor(vertical = true) {\n        this.vertical = vertical;\n        this.propsMap = vertical ? VerticalProps : HorizontalProps;\n    }\n    /**\n     * @return {?}\n     */\n    clientHeightKey() {\n        return this.propsMap.clientHeight;\n    }\n    /**\n     * @return {?}\n     */\n    offsetHeightKey() {\n        return this.propsMap.offsetHeight;\n    }\n    /**\n     * @return {?}\n     */\n    scrollHeightKey() {\n        return this.propsMap.scrollHeight;\n    }\n    /**\n     * @return {?}\n     */\n    pageYOffsetKey() {\n        return this.propsMap.pageYOffset;\n    }\n    /**\n     * @return {?}\n     */\n    offsetTopKey() {\n        return this.propsMap.offsetTop;\n    }\n    /**\n     * @return {?}\n     */\n    scrollTopKey() {\n        return this.propsMap.scrollTop;\n    }\n    /**\n     * @return {?}\n     */\n    topKey() {\n        return this.propsMap.top;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @param {?} alwaysCallback\n * @param {?} shouldFireScrollEvent\n * @param {?} isTriggeredCurrentTotal\n * @return {?}\n */\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n    if (alwaysCallback && shouldFireScrollEvent) {\n        return true;\n    }\n    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createResolver({ windowElement, axis }) {\n    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);\n}\n/**\n * @param {?} resolver\n * @param {?} windowElement\n * @return {?}\n */\nfunction createResolverWithContainer(resolver, windowElement) {\n    /** @type {?} */\n    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)\n        ? windowElement\n        : windowElement.nativeElement;\n    return Object.assign({}, resolver, { container });\n}\n/**\n * @param {?} windowElement\n * @return {?}\n */\nfunction isElementWindow(windowElement) {\n    /** @type {?} */\n    const isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));\n    return isWindow;\n}\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\nfunction getDocumentElement(isContainerWindow, windowElement) {\n    return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePoints(element, resolver) {\n    /** @type {?} */\n    const height = extractHeightForElement(resolver);\n    return resolver.isWindow\n        ? calculatePointsForWindow(height, element, resolver)\n        : calculatePointsForElement(height, element, resolver);\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForWindow(height, element, resolver) {\n    const { axis, container, isWindow } = resolver;\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    // scrolled until now / current y point\n    /** @type {?} */\n    const scrolled = height +\n        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    /** @type {?} */\n    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    /** @type {?} */\n    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +\n        nativeElementHeight;\n    return { height, scrolled, totalToScroll, isWindow };\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForElement(height, element, resolver) {\n    const { axis, container } = resolver;\n    // perhaps use container.offsetTop instead of 'scrollTop'\n    /** @type {?} */\n    const scrolled = container[axis.scrollTopKey()];\n    /** @type {?} */\n    const totalToScroll = container[axis.scrollHeightKey()];\n    return { height, scrolled, totalToScroll, isWindow: false };\n}\n/**\n * @param {?} axis\n * @return {?}\n */\nfunction extractHeightPropKeys(axis) {\n    return {\n        offsetHeightKey: axis.offsetHeightKey(),\n        clientHeightKey: axis.clientHeightKey()\n    };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction extractHeightForElement({ container, isWindow, axis }) {\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n    if (isNaN(elem[offsetHeightKey])) {\n        /** @type {?} */\n        const docElem = getDocumentElement(isWindow, elem);\n        return docElem ? docElem[clientHeightKey] : 0;\n    }\n    else {\n        return elem[offsetHeightKey];\n    }\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementOffsetTop(elem, axis, isWindow) {\n    /** @type {?} */\n    const topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) {\n        // || elem.css('none')) {\n        return;\n    }\n    return (elem.getBoundingClientRect()[topKey] +\n        getElementPageYOffset(elem, axis, isWindow));\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementPageYOffset(elem, axis, isWindow) {\n    /** @type {?} */\n    const pageYOffset = axis.pageYOffsetKey();\n    /** @type {?} */\n    const scrollTop = axis.scrollTopKey();\n    /** @type {?} */\n    const offsetTop = axis.offsetTopKey();\n    if (isNaN(window[pageYOffset])) {\n        return getDocumentElement(isWindow, elem)[scrollTop];\n    }\n    else if (elem.ownerDocument) {\n        return elem.ownerDocument.defaultView[pageYOffset];\n    }\n    else {\n        return elem[offsetTop];\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} container\n * @param {?} distance\n * @param {?} scrollingDown\n * @return {?}\n */\nfunction shouldFireScrollEvent(container, distance, scrollingDown) {\n    /** @type {?} */\n    let remaining;\n    /** @type {?} */\n    let containerBreakpoint;\n    if (container.totalToScroll <= 0) {\n        return false;\n    }\n    /** @type {?} */\n    const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n    if (scrollingDown) {\n        remaining =\n            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n        containerBreakpoint = distance.down / 10;\n    }\n    else {\n        /** @type {?} */\n        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n        remaining = container.scrolled / totalHiddenContentHeight;\n        containerBreakpoint = distance.up / 10;\n    }\n    /** @type {?} */\n    const shouldFireEvent = remaining <= containerBreakpoint;\n    return shouldFireEvent;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @return {?}\n */\nfunction isScrollingDownwards(lastScrollPosition, container) {\n    return lastScrollPosition < container.scrolled;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @param {?} distance\n * @return {?}\n */\nfunction getScrollStats(lastScrollPosition, container, distance) {\n    /** @type {?} */\n    const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n    return {\n        fire: shouldFireScrollEvent(container, distance, scrollDown),\n        scrollDown\n    };\n}\n/**\n * @param {?} position\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scroll\n * @param {?} scrollState\n * @param {?} triggered\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @param {?} scrolledUntilNow\n * @param {?} totalToScroll\n * @return {?}\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScrollState {\n    /**\n     * @param {?} __0\n     */\n    constructor({ totalToScroll }) {\n        this.lastScrollPosition = 0;\n        this.lastTotalToScroll = 0;\n        this.totalToScroll = 0;\n        this.triggered = {\n            down: 0,\n            up: 0\n        };\n        this.totalToScroll = totalToScroll;\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    updateScrollPosition(position) {\n        return (this.lastScrollPosition = position);\n    }\n    /**\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateTotalToScroll(totalToScroll) {\n        if (this.lastTotalToScroll !== totalToScroll) {\n            this.lastTotalToScroll = this.totalToScroll;\n            this.totalToScroll = totalToScroll;\n        }\n    }\n    /**\n     * @param {?} scrolledUntilNow\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateScroll(scrolledUntilNow, totalToScroll) {\n        this.updateScrollPosition(scrolledUntilNow);\n        this.updateTotalToScroll(totalToScroll);\n    }\n    /**\n     * @param {?} scroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    updateTriggeredFlag(scroll, isScrollingDown) {\n        if (isScrollingDown) {\n            this.triggered.down = scroll;\n        }\n        else {\n            this.triggered.up = scroll;\n        }\n    }\n    /**\n     * @param {?} totalToScroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    isTriggeredScroll(totalToScroll, isScrollingDown) {\n        return isScrollingDown\n            ? this.triggered.down === totalToScroll\n            : this.triggered.up === totalToScroll;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} config\n * @return {?}\n */\nfunction createScroller(config) {\n    const { scrollContainer, scrollWindow, element, fromRoot } = config;\n    /** @type {?} */\n    const resolver = createResolver({\n        axis: new AxisResolver(!config.horizontal),\n        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n    });\n    /** @type {?} */\n    const scrollState = new ScrollState({\n        totalToScroll: calculatePoints(element, resolver)\n    });\n    /** @type {?} */\n    const options = {\n        container: resolver.container,\n        throttle: config.throttle\n    };\n    /** @type {?} */\n    const distance = {\n        up: config.upDistance,\n        down: config.downDistance\n    };\n    return attachScrollEvent(options).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[\"mergeMap\"])(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[\"of\"])(calculatePoints(element, resolver))), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[\"map\"])((positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[\"tap\"])(({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[\"tap\"])(({ scrollDown, stats: { totalToScroll } }) => {\n        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(toInfiniteScrollAction));\n}\n/**\n * @param {?} options\n * @return {?}\n */\nfunction attachScrollEvent(options) {\n    /** @type {?} */\n    let obs = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[\"fromEvent\"])(options.container, 'scroll');\n    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n    // Let's avoid calling the function unless needed.\n    // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n    if (options.throttle) {\n        obs = obs.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[\"sampleTime\"])(options.throttle));\n    }\n    return obs;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} stats\n * @param {?} distance\n * @return {?}\n */\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);\n    return {\n        scrollDown,\n        fire,\n        stats\n    };\n}\n/** @type {?} */\nconst InfiniteScrollActions = {\n    DOWN: '[NGX_ISE] DOWN',\n    UP: '[NGX_ISE] UP'\n};\n/**\n * @param {?} response\n * @return {?}\n */\nfunction toInfiniteScrollAction(response) {\n    const { scrollDown, stats: { scrolled: currentScrollPosition } } = response;\n    return {\n        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n        payload: {\n            currentScrollPosition\n        }\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollDirective {\n    /**\n     * @param {?} element\n     * @param {?} zone\n     */\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.scrolled = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter\"]();\n        this.scrolledUp = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter\"]();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 150;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n        this.fromRoot = false;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n            this.setup();\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }) {\n        /** @type {?} */\n        const containerChanged = inputPropChanged(infiniteScrollContainer);\n        /** @type {?} */\n        const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        /** @type {?} */\n        const distanceChanged = inputPropChanged(infiniteScrollDistance);\n        /** @type {?} */\n        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n            (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n        if (containerChanged || disabledChanged || distanceChanged) {\n            this.destroyScroller();\n            if (shouldSetup) {\n                this.setup();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    setup() {\n        if (hasWindowDefined()) {\n            this.zone.runOutsideAngular(() => {\n                this.disposeScroller = createScroller({\n                    fromRoot: this.fromRoot,\n                    alwaysCallback: this.alwaysCallback,\n                    disable: this.infiniteScrollDisabled,\n                    downDistance: this.infiniteScrollDistance,\n                    element: this.element,\n                    horizontal: this.horizontal,\n                    scrollContainer: this.infiniteScrollContainer,\n                    scrollWindow: this.scrollWindow,\n                    throttle: this.infiniteScrollThrottle,\n                    upDistance: this.infiniteScrollUpDistance\n                }).subscribe((payload) => this.zone.run(() => this.handleOnScroll(payload)));\n            });\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    handleOnScroll({ type, payload }) {\n        switch (type) {\n            case InfiniteScrollActions.DOWN:\n                return this.scrolled.emit(payload);\n            case InfiniteScrollActions.UP:\n                return this.scrolledUp.emit(payload);\n            default:\n                return;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyScroller();\n    }\n    /**\n     * @return {?}\n     */\n    destroyScroller() {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    }\n}\nInfiniteScrollDirective.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Directive\"], args: [{\n                selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n            },] },\n];\n/** @nocollapse */\nInfiniteScrollDirective.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ElementRef\"] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"NgZone\"] }\n];\nInfiniteScrollDirective.propDecorators = {\n    scrolled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Output\"] }],\n    scrolledUp: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Output\"] }],\n    infiniteScrollDistance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    infiniteScrollUpDistance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    infiniteScrollThrottle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    infiniteScrollDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    infiniteScrollContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    scrollWindow: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    immediateCheck: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    horizontal: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    alwaysCallback: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }],\n    fromRoot: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"Input\"] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollModule {\n}\nInfiniteScrollModule.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"NgModule\"], args: [{\n                declarations: [InfiniteScrollDirective],\n                exports: [InfiniteScrollDirective],\n                imports: [],\n                providers: []\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n/**\n * Entry point for all public APIs of the package.\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=ngx-infinite-scroll.js.map\n\n\n/***/ })\n\n}]);\n//# sourceMappingURL=default~library-library-module~live-live-module~organisation-organisation-module-es2015.js.map","import { Directive, ElementRef, EventEmitter, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { fromEvent, of } from 'rxjs';\nimport { filter, map, mergeMap, sampleTime, tap } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @param {?} fromRoot\n * @return {?}\n */\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n    /** @type {?} */\n    const hasWindow = window && !!window.document && window.document.documentElement;\n    /** @type {?} */\n    let container = hasWindow && scrollWindow ? window : defaultElement;\n    if (selector) {\n        /** @type {?} */\n        const containerIsString = selector && hasWindow && typeof selector === 'string';\n        container = containerIsString\n            ? findElement(selector, defaultElement.nativeElement, fromRoot)\n            : selector;\n        if (!container) {\n            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n        }\n    }\n    return container;\n}\n/**\n * @param {?} selector\n * @param {?} customRoot\n * @param {?} fromRoot\n * @return {?}\n */\nfunction findElement(selector, customRoot, fromRoot) {\n    /** @type {?} */\n    const rootEl = fromRoot ? window.document : customRoot;\n    return rootEl.querySelector(selector);\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction inputPropChanged(prop) {\n    return prop && !prop.firstChange;\n}\n/**\n * @return {?}\n */\nfunction hasWindowDefined() {\n    return typeof window !== 'undefined';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst VerticalProps = {\n    clientHeight: \"clientHeight\",\n    offsetHeight: \"offsetHeight\",\n    scrollHeight: \"scrollHeight\",\n    pageYOffset: \"pageYOffset\",\n    offsetTop: \"offsetTop\",\n    scrollTop: \"scrollTop\",\n    top: \"top\"\n};\n/** @type {?} */\nconst HorizontalProps = {\n    clientHeight: \"clientWidth\",\n    offsetHeight: \"offsetWidth\",\n    scrollHeight: \"scrollWidth\",\n    pageYOffset: \"pageXOffset\",\n    offsetTop: \"offsetLeft\",\n    scrollTop: \"scrollLeft\",\n    top: \"left\"\n};\nclass AxisResolver {\n    /**\n     * @param {?=} vertical\n     */\n    constructor(vertical = true) {\n        this.vertical = vertical;\n        this.propsMap = vertical ? VerticalProps : HorizontalProps;\n    }\n    /**\n     * @return {?}\n     */\n    clientHeightKey() {\n        return this.propsMap.clientHeight;\n    }\n    /**\n     * @return {?}\n     */\n    offsetHeightKey() {\n        return this.propsMap.offsetHeight;\n    }\n    /**\n     * @return {?}\n     */\n    scrollHeightKey() {\n        return this.propsMap.scrollHeight;\n    }\n    /**\n     * @return {?}\n     */\n    pageYOffsetKey() {\n        return this.propsMap.pageYOffset;\n    }\n    /**\n     * @return {?}\n     */\n    offsetTopKey() {\n        return this.propsMap.offsetTop;\n    }\n    /**\n     * @return {?}\n     */\n    scrollTopKey() {\n        return this.propsMap.scrollTop;\n    }\n    /**\n     * @return {?}\n     */\n    topKey() {\n        return this.propsMap.top;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @param {?} alwaysCallback\n * @param {?} shouldFireScrollEvent\n * @param {?} isTriggeredCurrentTotal\n * @return {?}\n */\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n    if (alwaysCallback && shouldFireScrollEvent) {\n        return true;\n    }\n    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createResolver({ windowElement, axis }) {\n    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);\n}\n/**\n * @param {?} resolver\n * @param {?} windowElement\n * @return {?}\n */\nfunction createResolverWithContainer(resolver, windowElement) {\n    /** @type {?} */\n    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)\n        ? windowElement\n        : windowElement.nativeElement;\n    return Object.assign({}, resolver, { container });\n}\n/**\n * @param {?} windowElement\n * @return {?}\n */\nfunction isElementWindow(windowElement) {\n    /** @type {?} */\n    const isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));\n    return isWindow;\n}\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\nfunction getDocumentElement(isContainerWindow, windowElement) {\n    return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePoints(element, resolver) {\n    /** @type {?} */\n    const height = extractHeightForElement(resolver);\n    return resolver.isWindow\n        ? calculatePointsForWindow(height, element, resolver)\n        : calculatePointsForElement(height, element, resolver);\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForWindow(height, element, resolver) {\n    const { axis, container, isWindow } = resolver;\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    // scrolled until now / current y point\n    /** @type {?} */\n    const scrolled = height +\n        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    /** @type {?} */\n    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    /** @type {?} */\n    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +\n        nativeElementHeight;\n    return { height, scrolled, totalToScroll, isWindow };\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForElement(height, element, resolver) {\n    const { axis, container } = resolver;\n    // perhaps use container.offsetTop instead of 'scrollTop'\n    /** @type {?} */\n    const scrolled = container[axis.scrollTopKey()];\n    /** @type {?} */\n    const totalToScroll = container[axis.scrollHeightKey()];\n    return { height, scrolled, totalToScroll, isWindow: false };\n}\n/**\n * @param {?} axis\n * @return {?}\n */\nfunction extractHeightPropKeys(axis) {\n    return {\n        offsetHeightKey: axis.offsetHeightKey(),\n        clientHeightKey: axis.clientHeightKey()\n    };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction extractHeightForElement({ container, isWindow, axis }) {\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n    if (isNaN(elem[offsetHeightKey])) {\n        /** @type {?} */\n        const docElem = getDocumentElement(isWindow, elem);\n        return docElem ? docElem[clientHeightKey] : 0;\n    }\n    else {\n        return elem[offsetHeightKey];\n    }\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementOffsetTop(elem, axis, isWindow) {\n    /** @type {?} */\n    const topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) {\n        // || elem.css('none')) {\n        return;\n    }\n    return (elem.getBoundingClientRect()[topKey] +\n        getElementPageYOffset(elem, axis, isWindow));\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementPageYOffset(elem, axis, isWindow) {\n    /** @type {?} */\n    const pageYOffset = axis.pageYOffsetKey();\n    /** @type {?} */\n    const scrollTop = axis.scrollTopKey();\n    /** @type {?} */\n    const offsetTop = axis.offsetTopKey();\n    if (isNaN(window[pageYOffset])) {\n        return getDocumentElement(isWindow, elem)[scrollTop];\n    }\n    else if (elem.ownerDocument) {\n        return elem.ownerDocument.defaultView[pageYOffset];\n    }\n    else {\n        return elem[offsetTop];\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} container\n * @param {?} distance\n * @param {?} scrollingDown\n * @return {?}\n */\nfunction shouldFireScrollEvent(container, distance, scrollingDown) {\n    /** @type {?} */\n    let remaining;\n    /** @type {?} */\n    let containerBreakpoint;\n    if (container.totalToScroll <= 0) {\n        return false;\n    }\n    /** @type {?} */\n    const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n    if (scrollingDown) {\n        remaining =\n            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n        containerBreakpoint = distance.down / 10;\n    }\n    else {\n        /** @type {?} */\n        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n        remaining = container.scrolled / totalHiddenContentHeight;\n        containerBreakpoint = distance.up / 10;\n    }\n    /** @type {?} */\n    const shouldFireEvent = remaining <= containerBreakpoint;\n    return shouldFireEvent;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @return {?}\n */\nfunction isScrollingDownwards(lastScrollPosition, container) {\n    return lastScrollPosition < container.scrolled;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @param {?} distance\n * @return {?}\n */\nfunction getScrollStats(lastScrollPosition, container, distance) {\n    /** @type {?} */\n    const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n    return {\n        fire: shouldFireScrollEvent(container, distance, scrollDown),\n        scrollDown\n    };\n}\n/**\n * @param {?} position\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scroll\n * @param {?} scrollState\n * @param {?} triggered\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @param {?} scrolledUntilNow\n * @param {?} totalToScroll\n * @return {?}\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScrollState {\n    /**\n     * @param {?} __0\n     */\n    constructor({ totalToScroll }) {\n        this.lastScrollPosition = 0;\n        this.lastTotalToScroll = 0;\n        this.totalToScroll = 0;\n        this.triggered = {\n            down: 0,\n            up: 0\n        };\n        this.totalToScroll = totalToScroll;\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    updateScrollPosition(position) {\n        return (this.lastScrollPosition = position);\n    }\n    /**\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateTotalToScroll(totalToScroll) {\n        if (this.lastTotalToScroll !== totalToScroll) {\n            this.lastTotalToScroll = this.totalToScroll;\n            this.totalToScroll = totalToScroll;\n        }\n    }\n    /**\n     * @param {?} scrolledUntilNow\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateScroll(scrolledUntilNow, totalToScroll) {\n        this.updateScrollPosition(scrolledUntilNow);\n        this.updateTotalToScroll(totalToScroll);\n    }\n    /**\n     * @param {?} scroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    updateTriggeredFlag(scroll, isScrollingDown) {\n        if (isScrollingDown) {\n            this.triggered.down = scroll;\n        }\n        else {\n            this.triggered.up = scroll;\n        }\n    }\n    /**\n     * @param {?} totalToScroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    isTriggeredScroll(totalToScroll, isScrollingDown) {\n        return isScrollingDown\n            ? this.triggered.down === totalToScroll\n            : this.triggered.up === totalToScroll;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} config\n * @return {?}\n */\nfunction createScroller(config) {\n    const { scrollContainer, scrollWindow, element, fromRoot } = config;\n    /** @type {?} */\n    const resolver = createResolver({\n        axis: new AxisResolver(!config.horizontal),\n        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n    });\n    /** @type {?} */\n    const scrollState = new ScrollState({\n        totalToScroll: calculatePoints(element, resolver)\n    });\n    /** @type {?} */\n    const options = {\n        container: resolver.container,\n        throttle: config.throttle\n    };\n    /** @type {?} */\n    const distance = {\n        up: config.upDistance,\n        down: config.downDistance\n    };\n    return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map((positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({ scrollDown, stats: { totalToScroll } }) => {\n        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }), map(toInfiniteScrollAction));\n}\n/**\n * @param {?} options\n * @return {?}\n */\nfunction attachScrollEvent(options) {\n    /** @type {?} */\n    let obs = fromEvent(options.container, 'scroll');\n    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n    // Let's avoid calling the function unless needed.\n    // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n    if (options.throttle) {\n        obs = obs.pipe(sampleTime(options.throttle));\n    }\n    return obs;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} stats\n * @param {?} distance\n * @return {?}\n */\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);\n    return {\n        scrollDown,\n        fire,\n        stats\n    };\n}\n/** @type {?} */\nconst InfiniteScrollActions = {\n    DOWN: '[NGX_ISE] DOWN',\n    UP: '[NGX_ISE] UP'\n};\n/**\n * @param {?} response\n * @return {?}\n */\nfunction toInfiniteScrollAction(response) {\n    const { scrollDown, stats: { scrolled: currentScrollPosition } } = response;\n    return {\n        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n        payload: {\n            currentScrollPosition\n        }\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollDirective {\n    /**\n     * @param {?} element\n     * @param {?} zone\n     */\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.scrolled = new EventEmitter();\n        this.scrolledUp = new EventEmitter();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 150;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n        this.fromRoot = false;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n            this.setup();\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }) {\n        /** @type {?} */\n        const containerChanged = inputPropChanged(infiniteScrollContainer);\n        /** @type {?} */\n        const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        /** @type {?} */\n        const distanceChanged = inputPropChanged(infiniteScrollDistance);\n        /** @type {?} */\n        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n            (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n        if (containerChanged || disabledChanged || distanceChanged) {\n            this.destroyScroller();\n            if (shouldSetup) {\n                this.setup();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    setup() {\n        if (hasWindowDefined()) {\n            this.zone.runOutsideAngular(() => {\n                this.disposeScroller = createScroller({\n                    fromRoot: this.fromRoot,\n                    alwaysCallback: this.alwaysCallback,\n                    disable: this.infiniteScrollDisabled,\n                    downDistance: this.infiniteScrollDistance,\n                    element: this.element,\n                    horizontal: this.horizontal,\n                    scrollContainer: this.infiniteScrollContainer,\n                    scrollWindow: this.scrollWindow,\n                    throttle: this.infiniteScrollThrottle,\n                    upDistance: this.infiniteScrollUpDistance\n                }).subscribe((payload) => this.zone.run(() => this.handleOnScroll(payload)));\n            });\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    handleOnScroll({ type, payload }) {\n        switch (type) {\n            case InfiniteScrollActions.DOWN:\n                return this.scrolled.emit(payload);\n            case InfiniteScrollActions.UP:\n                return this.scrolledUp.emit(payload);\n            default:\n                return;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyScroller();\n    }\n    /**\n     * @return {?}\n     */\n    destroyScroller() {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    }\n}\nInfiniteScrollDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n            },] },\n];\n/** @nocollapse */\nInfiniteScrollDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone }\n];\nInfiniteScrollDirective.propDecorators = {\n    scrolled: [{ type: Output }],\n    scrolledUp: [{ type: Output }],\n    infiniteScrollDistance: [{ type: Input }],\n    infiniteScrollUpDistance: [{ type: Input }],\n    infiniteScrollThrottle: [{ type: Input }],\n    infiniteScrollDisabled: [{ type: Input }],\n    infiniteScrollContainer: [{ type: Input }],\n    scrollWindow: [{ type: Input }],\n    immediateCheck: [{ type: Input }],\n    horizontal: [{ type: Input }],\n    alwaysCallback: [{ type: Input }],\n    fromRoot: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollModule {\n}\nInfiniteScrollModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [InfiniteScrollDirective],\n                exports: [InfiniteScrollDirective],\n                imports: [],\n                providers: []\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n/**\n * Entry point for all public APIs of the package.\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule };\n//# sourceMappingURL=ngx-infinite-scroll.js.map\n"]}